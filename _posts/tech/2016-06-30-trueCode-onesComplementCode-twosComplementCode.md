---
layout: post
title: 原码，反码，补码
category: 技术
tags: 技术
keywords: 位操作
---

## 一. 机器数和真值

#### 1、机器数
```
一个数在计算机中的二进制表示形式, 叫做这个数的机器数。
机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.
比如，
+3 ，就是00000011
-3 ，就是10000011 。
这里的 00000011 和 10000011 就是机器数。
```

#### 2、真值
```
第一位是符号位，因此机器数的形式值不等于真正的数值。
例如上面的有符号数 10000011，
形式值是：131（转换成十进制等于131）
真正数值：-3
所以，为区别起见，"带符号位的机器数对应的真正数值"称为"机器数的真值"。
例如：
0000 0001的真值 = +000 0001 = +1，
1000 0001的真值 = –000 0001 = –1
```

## 二. 原码, 反码, 补码的基础概念和计算方法.

#### 1. 原码
```
原码就是: 符号位 + 真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如,

[+1]原 = 0000 0001
[-1]原 = 1000 0001

第一位是符号位, 所以8位二进制数的取值范围就是:

[1111 1111 , 0111 1111] ==> [-127 , 127]

原码是人脑最容易理解和计算的表示方式.
```

#### 2. 反码
```
正数的反码-->是本身
负数的反码-->在原码的基础上, 符号位不变，其它位取反.

[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反

负数反码, 人脑无法直观的看出数值. 要将其转换成原码再计算.
```

#### 3. 补码
```
正数的补码-->是本身
负数的补码-->在原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即反码+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补
[-1] = [10000001]原 = [11111110]反 = [11111111]补

负数补码，也是人脑无法直观看出其数值. 要转换成原码在计算其数值.
```

## 三. 为何要使用原码, 反码和补码

#### 正数的三种编码方式的结果都相同:
```
[+1] = [00000001]原 = [00000001]反 = [00000001]补
```

#### 负数的三种编码方式都不同:
```
[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

#### 为何还会有反码和补码呢?
```
人脑可识别第一位是符号位, 计算时人脑会根据符号位, 选择对真值区域的加减.

但计算机, 辨别"符号位"显然会让计算机的基础电路设计变复杂!

于是提出“符号位参与运算的方法”.

我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0

所以机器可以只有加法而没有减法, 这样计算机运算的设计就简单了.

于是人们开始探索 “符号位参与运算, 且只保留加法”的计算机计算方式.
```


#### 使用原码，“符号位参与运算，且只保留加法”
```
计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

“用原码，符号位也参与计算, 且只保留加法”，

显然其减法的结果是不正确的. 因此，计算机不使用原码表示一个数.
```

#### 使用反码，“符号位参与运算，且只保留减法”
```
为解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原
                 = [0000 0001]反 + [1111 1110]反
                 = [1111 1111]反
                 = [1000 0000]原
                 = -0

“用反码, 符号位参与计算，且只保留加法”，

结果的真值部分是正确的.
而唯一的问题其实就出现在"0"这个特殊的数值上.

虽然理解上"+0"和"-0"是一样的,
但是0带符号是没意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:
```


#### 使用补码, “符号位参与运算，且只保留加法”
```
使用补码的出现, 解决了用反码时"0的符号"以及"两个编码"的问题:

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原
               = [0000 0001]补 + [1111 1111]补
               = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 以前出现的-0不存在了.又可用[1000 0000]表示-128:

又例如，
(-1) + (-127) = [1000 0001]原 + [1111 1111]原
              = [1111 1111]补 + [1000 0001]补
              = [1000 0000]补
-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128.

注意：
但注意因为实际上是用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.
(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅修复了0的符号以及存在两个编码的问题, 而且还能多表示一个最低数.

这就是为何8位二进制,
原码表示范围：[-127, +127]
反码表示范围：[-127, +127]
补码表示范围：[-128, +127].

因为机器使用补码, 所以常用的32位int型, 可以表示范围是: [-2^31, 2^31 -1]
第一位表示的是符号位.使用补码又可以多保存一个最小值.
```

## 四. 原码, 反码, 补码 再深入

#### 同余的概念
```
整数a，b，若它们除以整数m的余数相等，则a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。

例如:
  4  mod 12 = 4
  16 mod 12 = 4
  28 mod 12 = 4
所以4, 16, 28 关于模 12 同余.
```

#### 负数取模

```
正数取模，容易理解：
5 mod 3 = 2

负数取模，要理解取模运算的数学定义：
x mod y = x - y * floor(x/y)
其中floor(x)称为向下取整函数，表示不超过x的最大整数。

举例:
  -3 mod 2
= -3 - 2xL -3/2 J
= -3 - 2xL-1.5J
= -3 - 2x(-2)
= -3 + 4 = 1

所以:
(-2) mod 12 = -2 - 12 * floor(-2/12) = 10
(-4) mod 12 = -4 - 12 * floor(-4/12) = 8
(-5) mod 12 = -5 - 12 * floor(-5/12) = 7
```

#### 小于模的相反数的余数和==模本身
```
2与-2互为相反数。

x  mod y = x  - y * floor(x/y)
-x mod y = -x - y * floor(-x/y)
所以,
 (x mod y) + (-x mod y)
= -y * [floor(x/y)+floor(-x/y)] 注意x < y
= -y * (-1)
=  y

 2 mod 3 = 2
-2 mod 3 = -2 - 3*floor(-2/3)
         = -2 - 3*floor(-0.66)
         = -2 + 3
         = 1
```

#### 线性运算定理
```
如果a ≡ b (mod m)，c ≡ d (mod m) 那么:
(1)a ± c ≡ b ± d (mod m)
(2)a * c ≡ b * d (mod m)

举例，
7    ≡ 7  (mod 12)
(-2) ≡ 10 (mod 12)
可得，
7 -2 ≡ 7 + 10 (mod 12)
```

#### 回到二进制 [-1同余126 类比 时钟的-1点同余11点]
```
回到二进制上, 看一下: 2-1=1的问题.

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原
           = [0000 0010]反 + [1111 1110]反

而-1的反码表示是1111 1110.
如果将[1111 1110]认为是原码, 则[1111 1110]原 = -126,
[因为小于模的相反数的余数和==模本身]
-126 ≡ 126(mod 127), -126和126同余
如果将符号位除去, 即认为是126.

发现有如下规律(100000001--11111111，共128-1=127格):
(-1) mod 127 = 126
126  mod 127 = 126
[类比时钟，-1点和11点是同余]

即:
2    ≡ 2(mod 127)
(-1) ≡ 126(mod 127), -1和126同余
可得，
2-1  ≡ 2+126 (mod 127)

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1

[因为 原码+反码 = 0111 1111 = 127]
例如，a= -1, b = -126
a mod 127
= (127 - a) mod 127
= b mod 127

所以说一个数的反码, 实际上是这个数对于一个膜(127)的同余数.

而这个膜并不是我们的二进制, 而是所能表示的最大值(1111 1111, 类比于11点钟)
这就和钟表一样, 转一圈后总能找到在可表示范围内的一个正确的数值!

而2+126很显然相当于钟表转过了一轮,
而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.
```

#### 为何还要用补码呢? 为何反码加1, 还能得到正确结果?
```
0000 0001 --> 0111 1111, 共127位
0000 0000 --> 0111 1111, 共128位

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原
           = [0000 0010]补 + [1111 1111]补

如果把[1111 1111]当成原码, 去除符号位, 则: [0111 1111]原 = 127

[其实, 在反码的基础上+1, 只是相当于增加了膜的值!]:

即，
(-1) mod 128 = 127
127  mod 128 = 127
可得，
2-1 ≡ 2+127 (mod 128)

此时, 表盘相当于每128个刻度一轮. 所以用补码表示的最大和最小是[-128, 128].

但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]
```
