---
layout: post
title:  backtracking
category: 算法
tags: [backtracking, 回溯法]
keywords: algorithm, backtracking
---

### 1.回溯法算法思想

```
定义：

回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。
但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

1、回溯法适用：
   许多问题，当需要找出它的解集（全部解）或要求回答什么解是满足某些约束条件的最优解时，
   往往要使用回溯法。

2、有组织的穷举式搜索：
   回溯法的基本做法是搜索或者有的组织穷尽搜索。避免搜索所有的可能性。即避免不必要的搜索。
   这种方法适用于解一些组合数相当大的问题。

3、搜索解空间树：
   回溯法在问题的解空间树中，按深度优先策略（DFS），从根结点出发搜索解空间树。
   算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。
   如果肯定不包含（剪枝过程），则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；
   否则，进入该子树，继续按深度优先策略搜索。

为了实现回溯，我们先弄明白以下两个问题：

1）首先应该明确问题的解空间。

2）其次是组织解空间以便它能用以被搜索到。
```


### 1、概念

```
回溯算法实际上是一个类似枚举的搜索尝试过程，是在搜索尝试过程中寻找问题的解，
当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。
但当探索到某一步时，发现原选择不优或达不到目标，就退一步重新选择，
这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

许多复杂的，规模较大的问题都可用回溯法，有“通用解题方法”的美称。
回溯的三个重要概念如下:

（一）约束函数：
约束函数是根据题意定出的。
通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。
因此，约束函数是对于任何状态空间树上的节点都有效、等价的。
（二）状态空间树：
上文提到过，状态空间树是一个对所有解的图形描述。
树上的每个子节点的解都只有一个部分与父节点不同。
（三）扩展节点、活结点、死结点：
所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。
活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；
死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。
```

### 2、基本思想

```
在包含问题的所有解的解空间树中，
按照深度优先搜索的策略，从根结点出发深度探索解空间树。

当探索到某一结点时，要先判断该结点是否包含问题的解，
如果包含，就从该结点出发继续探索下去，
如果该结点不包含问题的解，则逐层向其祖先结点回溯。
（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时:
要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

若用回溯法求任一个解时:
只要搜索到问题的一个解就可以结束。
```

### 3、回溯法解题的一般步骤

```
（1）针对所给问题，确定问题的解空间：

     首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

（2）确定结点的扩展搜索规则

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
```

### 4、算法框架

```
（1）问题框架

     设问题的解是一个n维向量(a1,a2,………,an),
     约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。

（2）非递归回溯框架

1: int a[n],i;
2: 初始化数组a[];
3: i = 1;
4: while (i>0(有路可走)   and  (未达到目标)) // 还未回溯到头
5: {
6:     if(i > n)                             // 搜索到叶结点
7:     {   
8:           搜索到一个解，输出；
9:     }
10:     else                                 // 处理第i个元素
11:     { 
12:           a[i]第一个可能的值；
13:           while(a[i]在不满足约束条件且在搜索空间内)
14:           {
15:               a[i]下一个可能的值；
16:           }
17:           if(a[i]在搜索空间内)
18:          {
19:               标识占用的资源；
20:               i = i+1;                   // 扩展下一个结点
21:          }
22:          else 
23:         {
24:               清理所占的状态空间；       // 回溯
25:               i = i –1; 
26:          }
27: }
 

（3）递归的算法框架

回溯法是对解空间的深度优先搜索，一般情况下使用递归函数来回溯法比较简单，
其中i为搜索的深度，框架如下：

1: int a[n];
2: try(int i)
3: {
4:     if(i>n)
5:        输出结果;
6:      else
7:     {
8:        for(j = 下界; j <= 上界; j=j+1)    // 枚举i所有可能的路径
9:        {
10:            if(fun(j))                    // 满足限界函数和约束条件
11:              {
12:                 a[i] = j;
13:               ...                        // 其他操作
14:                 try(i+1);
15:               回溯前的清理工作（如a[i]置空值等）;
16:               }
17:          }
18:      }
19: }

```

### 原文链接

[Blog1](http://www.cnblogs.com/welen/archive/2014/07/14/3843774.html)
[Blog2](http://blog.csdn.net/hguisu/article/details/7709276)
